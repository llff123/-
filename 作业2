1.上下文切换
  含义：先把前一个任务的cpu上下文（也就是CPU寄存器和程序计数器）保存起来，然后加载新任务的上下午到这些寄存器和程序计数器，最后跳转到程序计数器所指的新位置，运行新任务
2.进程上下午切换：是从一个进程切换到另外一个进程运行，需要保存虚拟内存、栈、全局变量等用户空间的资源，包括内核堆栈、寄存器等空间状态
3.线程上下文切换：
  线程是调度的基本单位，而进程是资源分配的基本单位
  内核中的任务调度，实际上的调度对象是线程，进程只是给线程提供了虚拟内存、全局变量等资源
  线程上下文切换分为两种情况：
    a.前后两个线程属于不同的进程，这时资源不共享，索引切换过程就是和进程上下文切换一样
    b.前后两个线程属于同个进程，此时虚拟内存共享，在切换时，共享资源保存不动，只需切换线程的私有资源，如寄存器等不共享的数据
4.中端上下午切换：为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件，在打断其他进程时，需要将进程的当前状态保存下来，这样在中断结束之后，进程热仍然可以从原来的状态恢复运行
  上文总结：
    不管是哪种场景导致的上下文切换，都需要知道：
    1.CPU上下文切换，是保证Linux系统正常工作的核心功能之一，一般情况下不需特别关注
    2.但过多的上下文切换，会消耗大量CPU时间在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正的运行时间，导致系统的整体性能下降
    
vmstat：一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，分析上下文切换和中断的次数
不同参数含义：
-a, --active          active/inactive memory  --显示活跃/不活跃的内存
-f, --forks           number of forks since boot  --自启动的fork数量
-m, --slabs           slabinfo  --显示slabs相关信息
-n, --one-header      do not redisplay header  --只在开始时显示一次各字段名称
-s, --stats           event counter statistics  --显示内存相关统计信息及多种系统活动数量
-d, --disk            disk statistics   --显示磁盘相关统计信息
-D, --disk-sum        summarize disk statistics   --总结磁盘统计信息
-p, --partition <dev> partition specific statistics --划分特定磁盘相关统计信息
-S, --unit <char>     define display unit --使用指定单位显示
-w, --wide            wide output --宽输出
-t, --timestamp       show timestamp  --显示时间戳
-h, --help            display this help and exit  --显示帮助和退出
-V, --version         output version information and exit --输出版本信息和退出

操作分析过程：
1.在第一个终端里运行sysbench，模拟系统多线程调度的瓶颈
  sysbench --threads=10 --time=300 threads run(运行10个线程跑5分钟，模拟多线程切换)
2.多开窗口，输入vmstat 3--每隔3s输出一组数据
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     9  0      0 1396076    172 323816    0    0    15  9585  268  638 20  1 75  4  0
     5  0      0 1396076    172 323816    0    0     0     0 42696 1971491 18 69 13  0  0
     6  0      0 1396076    172 323816    0    0     0     0 43288 1925472 18 70 12  0  0
     5  0      0 1396076    172 323816    0    0     0     0 42670 2006475 18 70 12  0  0
     7  0      0 1396116    172 323816    0    0     0     0 40278 1859488 18 69 13  0  0

  pros（r：表示运行和等待CPU时间片的进程数，这个值如果长期大于CPU数，说明CPU不足，出现了过载
        b：表示在等待资源的进程数，比如正在等待I/O或者内存交换）
  memory（sqpd：表示切换到内存交互区的内存大小，单位kb，也就是虚拟内存的大小
          free：表示当前空闲的物理内存，单位kb
          buffer：表示buffercached内存大小，也就是缓冲大小，一般对块设备的读写才需要缓冲
          cache：表示pagecache的内存大小，也就是缓存大小，一般为文件系统进程缓存
  ）频繁访问的文件都会缓存，如果cache值非常大说明缓存文件比较多，这个时候io中bi比较小，说明文件系统效率比较好
  swap（si：内存进入到内存交换区的内存大小
        so：内存交换区进入到内存的内存大小）一般情况下，si、so的值都为0，如果长期不为0，说明系统内存不足，需要增加系统内存
  io（bi：读磁盘，单位kb/s
      bo：写磁盘，单位kb/s）
  system（in：表示某一时间间隔内的每秒设备中断数
          cs：表示每次产生的上下文切换次数
  ）这两个值越大，则由内核消耗的CPU就越多
  cpu（us：用户态CPU占用的百分比，us值越高，说明用户进程消耗CPU时间越多
       sy：系统内核进程消耗的CPU时间的百分比-----一般来说us+sy应该小于80%，如果大于80%，说明CPU处于瓶颈
       id：表示CPU处于空闲状态的时间百分比
       wa：表示等待CPU的时间百分比，wa值越高，说明I/O等待越严重，参考值：不超过20%）
       引起I/O等待的原因可能是磁盘大量随机读写操作造成的
       通过上面我们可以看到，重点关注以下几个数据：
          r、us、sy、wa
          
[root@localhost ~]# vmstat 3
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 4  0      0 1395852    172 323808    0    0     5  3222  249  367  7  1 91  1  0
 8  0      0 1395844    172 323808    0    0     0     0 34352 1908612 17 70 13  0  0
 6  0      0 1395844    172 323808    0    0     0     0 26758 1732511 17 69 14  0  0
 5  0      0 1395844    172 323808    0    0     0     0 32219 1821766 16 71 13  0  0
 8  0      0 1395844    172 323808    0    0     0     0 31717 1769349 17 69 14  0  0
 6  0      0 1395844    172 323808    0    0     0     0 31395 1744251 17 69 14  0  0
 7  0      0 1395844    172 323808    0    0     0     0 34473 1793113 17 70 13  0  0
    通过vmstat这个指令动态输出数据，可以发现cs这一列的值发生明显变化，从367到1908612
    r列进程数值明显大于4，说明有大量CPU竞争
    用户态us和系统态sy这两列的CPU使用率超过了80%，sy差不多在70%，说明CPU主要被内核占用
  分析：r值远大于系统cpu核数，说明有大量运行和等待CPU的进程，就会产生大量的CPU上下文切换，而上下文切换又导致了系统CPU占用率升高
        此时应该分析是哪些等待的进程导致了CPU占用率升高？
3.新开窗口pidstat -wu 1指令输出一组数据（-w：输出进程切换指标；-u：输出CPU使用指标）
05:25:58 PM   UID       PID    %usr %system  %guest    %CPU   CPU  Command
05:25:59 PM     0       921    0.00    1.00    0.00    1.00     1  vmtoolsd
05:25:59 PM     0     11836   73.00  100.00    0.00  100.00     3  sysbench
05:25:59 PM     0     11861    1.00    1.00    0.00    2.00     0  pidstat

05:25:58 PM   UID       PID   cswch/s nvcswch/s  Command
05:25:59 PM     0         9      1.00      0.00  ksoftirqd/0
05:25:59 PM     0        10     27.00      0.00  rcu_sched
05:25:59 PM     0        16      1.00      0.00  ksoftirqd/1
05:25:59 PM     0       416      3.00      0.00  irq/16-vmwgfx
05:25:59 PM     0       470      1.00      0.00  kworker/0:1H-kblockd
05:25:59 PM     0       921     14.00      0.00  vmtoolsd
05:25:59 PM     0      1295      1.00      0.00  php-fpm
05:25:59 PM     0      4032      1.00      0.00  sshd
05:25:59 PM     0     11763      2.00      0.00  kworker/3:0-mpt_poll_0
05:25:59 PM     0     11764     28.00      0.00  kworker/2:1-events_power_efficient
05:25:59 PM     0     11774      1.00      0.00  kworker/u256:2-events_unbound
05:25:59 PM     0     11835      7.00      0.00  kworker/0:0-events
05:25:59 PM     0     11860      1.00      0.00  kworker/0:2-ata_sff
05:25:59 PM     0     11861      1.00      0.00  pidstat
  可以发现导致CPU使用率升高的进程是sysbench导致的；
    cswch/s：每秒自愿上下文切换的次数--指进程无法获取所需资源，导致的上下文切换；如I/O，内存资源不足时
    nvcswch/s：每秒非自愿上下文切换的次数--指进程由于时间片已到等原因，被系统强制调度，发生的上下文切换；如大量进程抢夺CPU时
    
  从上面的输出可以看出，vmstat里大量产生上下文切换次数，pidstat里的自愿/非自愿上下文切换次数却不多，是什么原因呢？
    因为pidstat监控的是进程，而Linux进行调度的基本单位是线程，所有我们需要增加参数去输出线程数据：pidstat -wt 3 1（隔三秒输出一组线程数据）
05:36:30 PM   UID      TGID       TID   cswch/s nvcswch/s  Command
05:36:31 PM     0         -     11985  38639.00 157041.00  |__sysbench
05:36:31 PM     0         -     11986  33074.00 149431.00  |__sysbench
05:36:31 PM     0         -     11987  35100.00 158502.00  |__sysbench
05:36:31 PM     0         -     11988  34981.00 141777.00  |__sysbench
05:36:31 PM     0         -     11989  31722.00 140675.00  |__sysbench
05:36:31 PM     0         -     11990  30856.00 157917.00  |__sysbench
05:36:31 PM     0         -     11991  32459.00 156930.00  |__sysbench
05:36:31 PM     0         -     11992  33749.00 142212.00  |__sysbench
05:36:31 PM     0         -     11993  32393.00 163347.00  |__sysbench
05:36:31 PM     0         -     11994  35027.00 154486.00  |__sysbench
05:36:31 PM     0         -     11995  32970.00 161242.00  |__sysbench
05:36:31 PM     0         -     11996  36413.00 136253.00  |__sysbench
  可以发现，sysbench进程的上下文切换次数不多，但是它的子线程的上下文切换次数就相当多了，即压力来自sysbench这个工具
总结：自愿上下文切换的次数多了，说明等待CPU的进程增加，可能是产生大量I/O问题导致的；
      非自愿上下文切换次数增加，说明进程都在被系统强制调度，即都在抢夺CPU，说明CPU出现了过载情况
  
